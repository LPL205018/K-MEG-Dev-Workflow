# 開發守則：第一部分 - 架構穩定性與設計原則 (Structural Integrity)
# 版本：v1.0 | 狀態：MANDATORY (強制執行)

## 1. 職責解耦規範 (Decoupling & SRP)
* **單一事實來源 (SSOT):** 任何特定的業務邏輯、數據結構或計算公式，在代碼庫中必須「有且僅有一個」定義位置。嚴禁在不同模組中重複相似邏輯。
* **物理隔離標準:**
    * **Logic vs. IO:** 核心業務邏輯（Domain Logic）禁止直接依賴外部 IO（資料庫、網路 API、檔案系統）。必須透過抽象介面（Interface/Abstract Class）進行溝通。
    * **Stateless Core:** 盡可能將邏輯封裝於「純函數 (Pure Functions)」中，確保輸入輸出的一致性，降低狀態追蹤的複雜度。
* **組件規模限制:**
    * 單一函數代碼嚴禁超過 50 行（邏輯行）。
    * 單一類別/檔案嚴禁超過 300 行。若超出，必須啟動「領域拆分」程序。

## 2. 依賴與擴展合規 (Open-Closed & Dependency)
* **依賴注入 (DI):** 禁止在組件內部實例化依賴對象（禁止使用 `new` 關鍵字於具體實作類）。所有依賴必須由外部注入，以確保組件的可測試性。
* **介面優先原則:** 模組間的互動必須基於「契約（Contract/Interface）」而非「實作」。
    * *規則：* 修改實作內容不應導致調用端需要重新改動。
* **禁止向上依賴:** 低層級模組（如工具類、數據庫封裝）嚴禁引用高層級模組（業務場景、工作流）。

## 3. 系統熵值控制 (Complexity Management)
* **拒絕過度工程 (YAGNI):** 嚴禁為「未來可能」的需求預留複雜的架構。僅針對當前已知需求進行最優化設計，但保持代碼的「可重構性」。
* **火車殘骸禁止 (Law of Demeter):** 嚴禁連續跨級調用對象屬性。
    * *錯誤範例：* `order.getCustomer().getAddress().getCity()`
    * *正確做法：* `order.getDestinationCity()`
* **循環依賴熔斷:** 代碼庫中嚴禁出現循環引用（A -> B -> A）。一旦偵測到循環路徑，必須立即重構為第三方仲裁者模式。

## 4. 錯誤處理與防禦架構 (Error Boundary)
* **崩潰防護:** 在系統關鍵邊界（邊緣 API、第三方服務調用）必須設置錯誤邊界（Error Boundaries）。
* **防衛性程式碼:** 函數進入點必須執行「前置條件檢查（Assertions）」。
    * 對於 `null`、`undefined` 或非法範圍值，應在函數起始處立即中斷並拋出具備語義的異常，而非容許其進入邏輯深處。